<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>3.Java多线程 - Cccccpg</title>

  
    <meta name="description" content="该部分主要总结了Java中各种锁、关键字、线程池、多线程等相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="3.Java多线程">
<meta property="og:url" content="https://cccccpg.github.io/2023/06/20/3-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Cccccpg">
<meta property="og:description" content="该部分主要总结了Java中各种锁、关键字、线程池、多线程等相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679966985373-41a0f2bf-5cdf-4f2d-87fe-a3e66e9ae188.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679968427866-c1eab9a8-2a75-46a9-a788-7b65cbc93cb0.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679971332893-1221d08f-561e-4b6c-98df-7878b3c46c92.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679972267521-94b147b9-4101-4a3c-929e-0a7d583890af.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679985603801-0dd06916-a144-4e5e-bbde-d3b1620eb47f.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679986933617-7cfc130e-49f5-4e4c-a986-d0bf750507eb.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679990092390-4558bb87-ad46-44ef-86c3-9d35747cf21b.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1680060401101-d4bbca67-b73f-4326-a23a-01b91ac1998a.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1680077763217-dbbeb71d-40bf-4268-8a6b-c6e5765b8293.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230901104453943.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331142513380.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331142651178.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230901104759524.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331150713518.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230731144913812.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331170315399.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410153830053.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410154615916.png">
<meta property="og:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410171701107.png">
<meta property="article:published_time" content="2023-06-20T07:41:04.000Z">
<meta property="article:modified_time" content="2023-09-12T02:40:39.128Z">
<meta property="article:author" content="Cccccpg">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="基础">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679966985373-41a0f2bf-5cdf-4f2d-87fe-a3e66e9ae188.png">
  
  
  
  <meta name="keywords" content="Java,八股,基础,面试">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/%E5%A4%B4%E5%83%8F.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Cccccpg</div><div class="sub cap">热情，礼貌，一问三不知。</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/wiki/">别点</a><a class="nav-item" href="/about/">社交</a></nav>
</header>


<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">3.Java多线程</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">1、进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%8EJVM%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">1.1 从JVM角度理解进程与线程区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%9F"><span class="toc-text">1.2 虚拟机栈、本地方法栈和程序计数器为什么是私有的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="toc-text">1.3 什么是堆和方法区？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E5%87%A0%E4%B8%AA%E5%8C%BA%E5%88%AB"><span class="toc-text">2、几个区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.1 并发与并行的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.2 同步与异步的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3、多线程的优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-text">4、什么是线程的上下文切换？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">5、守护线程和用户线程区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E6%AD%BB%E9%94%81%E3%80%81%E6%B4%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF"><span class="toc-text">6、死锁、活锁、饥饿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">6.1 死锁的四个必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">6.2 如何预防和避免死锁?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">6.2.1 如何预防死锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-text">6.2.2 如何避免死锁？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%AD%BB%E9%94%81%E3%80%81%E6%B4%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">6.3 死锁、活锁、饥饿的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">7、线程的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">8、创建线程的方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.1 继承Thread类创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.2 实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8Callable%E5%92%8CFuture%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.3 使用Callable和Future创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.4 使用线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81runnable%E5%92%8Ccallable%E5%8C%BA%E5%88%AB"><span class="toc-text">9、runnable和callable区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81start-%E5%92%8Crun"><span class="toc-text">10、start()和run()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">10.1 两者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8start%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8Crun%E6%96%B9%E6%B3%95%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8Crun%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">10.2 为什么调用start方法时会执行run方法，而不直接执行run方法？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">11、线程同步和调度的方法（对线程的控制方法）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81sleep-%E5%92%8Cyield-%E5%8C%BA%E5%88%AB"><span class="toc-text">12、sleep()和yield()区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81sleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13、sleep()和wait()的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">14、线程间通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%EF%BC%9F"><span class="toc-text">15、如何实现线程同步和互斥？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">16、线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">16.1 什么是线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">16.2 如何保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E4%BB%80%E4%B9%88%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="toc-text">16.3 线程安全体现在什么方面？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8BT1%E3%80%81T2%E3%80%81T3%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">17、如何让三个线程T1、T2、T3按顺序执行这类问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E5%A6%82%E4%BD%95%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">17.1 如何按顺序执行三个线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-1-1-synchronized-wait-notify"><span class="toc-text">17.1.1 synchronized + wait&#x2F;notify</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E6%89%93%E5%8D%B0n%E6%AC%A1ABC"><span class="toc-text">17.2 三个线程轮流打印n次ABC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-1-join-%E6%96%B9%E6%B3%95"><span class="toc-text">17.2.1 join()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-2-Lock%E9%94%81"><span class="toc-text">17.2.2 Lock锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-3-Lock-Condition%E7%B2%BE%E5%87%86%E5%94%A4%E9%86%92"><span class="toc-text">17.2.3 Lock+Condition精准唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%E7%9A%84%E5%A5%87%E5%81%B6%E6%95%B0"><span class="toc-text">17.3 两个线程交替打印1-100的奇偶数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-N%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B01-100"><span class="toc-text">17.4 N个线程循环打印1-100</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">18、synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E4%BB%80%E4%B9%88%E6%98%AFsynchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">18.1 什么是synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-Java%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">18.2 Java内存的可见性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E4%B8%8D%E5%8F%AF%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">18.2.1 什么是内存不可见问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">18.2.2 synchronized关键字是怎么解决的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">18.3 synchronized关键字三大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">18.4 synchronized关键字可以实现什么类型的锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">18.4.1 可重入锁的原理知道吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">18.5 使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">18.5.1 修饰普通同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-2-%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">18.5.2 修饰静态同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-3-%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%97"><span class="toc-text">18.5.3 修饰同步方法块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">18.6 底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-1-%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">18.6.1 修饰同步语块的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-2-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">18.6.2 修饰方法的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-3-%E6%80%BB%E7%BB%93"><span class="toc-text">18.6.3 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-6-4-%E8%83%BD%E5%85%B7%E4%BD%93%E8%AF%B4%E4%B8%80%E4%B8%8BMonitor%E5%90%97%EF%BC%9F"><span class="toc-text">18.6.4 能具体说一下Monitor吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-7-JDK1-6%E5%AF%B9synchronized%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">18.7 JDK1.6对synchronized做了哪些优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-8-synchronized%E5%92%8Clock%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">18.8 synchronized和lock两者的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-9-%E4%BA%86%E8%A7%A3ReentrantLock%E5%90%97%EF%BC%9F"><span class="toc-text">18.9 了解ReentrantLock吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-10-ReentrantLock%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">18.10 ReentrantLock和synchronized的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">19、volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E4%BC%9A%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-text">19.1 为什么代码会重排？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">19.2 重排序会引发什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-3-volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">19.3 volatile实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-1-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">19.3.1 实现可见性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-2-%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-text">19.3.2 实现有序性原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81synchronized%E5%92%8Cvolatile%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">20、synchronized和volatile的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">21、乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="toc-text">21.1 如何实现乐观锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2-%E4%B9%90%E8%A7%82%E9%94%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">21.2 乐观锁存在的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22%E3%80%81ThreadLocal"><span class="toc-text">22、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#22-1-%E4%BB%80%E4%B9%88%E6%98%AFThreadLocal%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">22.1 什么是ThreadLocal？有哪些应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-2-ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-text">22.2 ThreadLocal原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-3-%E4%BB%80%E4%B9%88%E5%AF%BC%E8%87%B4%E4%BA%86ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">22.3 什么导致了ThreadLocal内存泄露问题？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">23、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">23.1 什么是线程池？为什么使用线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">23.2 如何创建线程池？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8Executors%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-text">23.2.1  为什么不推荐使用Executors方式创建线程池？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%EF%BC%9F"><span class="toc-text">23.2.2 线程池核心参数有哪些？如何解释？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">23.2.3 线程池的拒绝策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">23.2.4 线程池常见的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-2-5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%89"><span class="toc-text">23.2.5 线程池处理任务的流程（线程池执行原理是什么？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-6-%E5%A6%82%E4%BD%95%E7%BB%99%E7%BA%BF%E7%A8%8B%E5%91%BD%E5%90%8D%EF%BC%9F"><span class="toc-text">23.3.6 如何给线程命名？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-7-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-text">23.3.7 如何合理配置线程池大小？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BB%BB%E5%8A%A1%E6%97%B6CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E8%BF%98%E6%98%AFIO%E5%AF%86%E9%9B%86%E5%9E%8B%EF%BC%9F"><span class="toc-text">23.3.8 如何判断任务时CPU密集型还是IO密集型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-9-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">23.3.9 线程池回收线程的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-3-10-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%B2%E7%BB%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-text">23.3.10 如何判断线程池已经执行完所有任务？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-text">23.3 线程池原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">23.4 几个常见的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#23-4-1-Runnable%E5%92%8CCallable"><span class="toc-text">23.4.1 Runnable和Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-4-2-excute-%E5%92%8Csubmit"><span class="toc-text">23.4.2 excute()和submit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-4-3-shutdown-%E5%92%8CshutdownNow"><span class="toc-text">23.4.3 shutdown()和shutdownNow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-4-4-isTerminated-%E5%92%8CisShutdown"><span class="toc-text">23.4.4 isTerminated()和isShutdown()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E3%80%81CAS"><span class="toc-text">24、CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1-CAS%E7%9A%84%E8%87%AA%E6%97%8B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-text">24.1 CAS的自旋过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-2-CAS%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-text">24.2 CAS存在什么问题？如何解决？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25%E3%80%81Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">25、Atomic原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#25-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">25.1 基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-2-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">25.2 数组类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">25.3 引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="toc-text">25.4 对象的属性修改类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E3%80%81AQS"><span class="toc-text">26、AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#26-1-%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-text">26.1 什么是AQS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-2-AQS%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">26.2 AQS的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-3-AQS%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-text">26.3 AQS资源共享方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-4-AQS%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">26.4 AQS是如何实现独占锁和共享锁的？</span></a></li></ol></li></ol></div></div></widget>



<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/Cccccpg" target="_blank" rel="external nofollow noopener noreferrer"><svg aria-hidden="true" height="24" viewBox="0 0 16 16" version="1.1" width="24" data-view-component="true" class="octicon octicon-mark-github"> <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path> </svg></a></div></footer>

    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java%E5%85%AB%E8%82%A1/">Java八股</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Java%E5%85%AB%E8%82%A1/%E5%9F%BA%E7%A1%80/">基础</a></div><div id="post-meta">发布于&nbsp;<time datetime="2023-06-20T07:41:04.000Z">2023-06-20</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>3.Java多线程</span></h1>
<h1 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h1><p><strong>进程：</strong>是程序的一次执行过程，是系统运行的基本单位，是操作系统资源分配的基本单位。<br><strong>线程：</strong>比进程更小的执行单位，是处理器任务调度和执行的基本单位，一个进程可以包含多个线程。多个线程可以共享进程的<strong>堆</strong>和<strong>方法区</strong>资源。</p>
<h2 id="1-1-从JVM角度理解进程与线程区别"><a href="#1-1-从JVM角度理解进程与线程区别" class="headerlink" title="1.1 从JVM角度理解进程与线程区别"></a>1.1 从JVM角度理解进程与线程区别</h2><p>Java 虚拟机的运行时数据区包含<strong>堆、方法区、虚拟机栈、本地方法栈、程序计数器</strong>。</p>
<p>各个进程之间是相互独立的，每个进程会包含多个线程，每个进程所包含的多个线程并不是相互独立的，这个线程会<strong>共享</strong>进程的堆和方法区，但这些线程<strong>不会共享</strong>虚拟机栈、本地方法栈、程序计数器。如下图所示，假设某个进程包含三个线程。  </p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679966985373-41a0f2bf-5cdf-4f2d-87fe-a3e66e9ae188.png" alt="运行时数据区"/></div><div class="image-meta"><span class="image-caption center">运行时数据区</span></div></div>

<ul>
<li><strong>内存分配：</strong>进程之间地址空间和资源是相互独立的，同一个进程之间的线程会共享进程的地址空间和资源。</li>
<li><strong>资源开销：</strong>每个进程具备各自的数据空间，进程之间的切换会有较大的开销。属于同一进程的线程会共享堆和方法区，同时具备私有的虚拟机栈、本地方法栈、程序计数器，线程之间切换资源开销较小，但不利于资源的管理和保护。</li>
</ul>
<h2 id="1-2-虚拟机栈、本地方法栈和程序计数器为什么是私有的？"><a href="#1-2-虚拟机栈、本地方法栈和程序计数器为什么是私有的？" class="headerlink" title="1.2 虚拟机栈、本地方法栈和程序计数器为什么是私有的？"></a>1.2 虚拟机栈、本地方法栈和程序计数器为什么是私有的？</h2><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<hr>
<p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。<br>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h2 id="1-3-什么是堆和方法区？"><a href="#1-3-什么是堆和方法区？" class="headerlink" title="1.3 什么是堆和方法区？"></a>1.3 什么是堆和方法区？</h2><p>堆和方法区是所有线程共享的资源，其中<strong>堆</strong>是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，<strong>方法区</strong>主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h1 id="2、几个区别"><a href="#2、几个区别" class="headerlink" title="2、几个区别"></a>2、几个区别</h1><h2 id="2-1-并发与并行的区别"><a href="#2-1-并发与并行的区别" class="headerlink" title="2.1 并发与并行的区别"></a>2.1 并发与并行的区别</h2><ul>
<li>并发：<strong>一个处理器</strong>处理<strong>多个任务</strong>，按时间片轮流处理多个任务。</li>
<li>并行：单位时间<strong>多个处理器</strong>同时处理<strong>多个任务</strong>。</li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679968427866-c1eab9a8-2a75-46a9-a788-7b65cbc93cb0.png" alt="并行与并发"/></div><div class="image-meta"><span class="image-caption center">并行与并发</span></div></div>

<h2 id="2-2-同步与异步的区别"><a href="#2-2-同步与异步的区别" class="headerlink" title="2.2 同步与异步的区别"></a>2.2 同步与异步的区别</h2><ul>
<li><strong>同步方法</strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</li>
<li><strong>异步方法</strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。</li>
</ul>
<h1 id="3、多线程的优缺点"><a href="#3、多线程的优缺点" class="headerlink" title="3、多线程的优缺点"></a>3、多线程的优缺点</h1><ul>
<li><p><strong>优点</strong>：当一个线程进入等待状态或者阻塞时，CPU 可以先去执行其他线程， 提高 CPU 的利用率。  </p>
</li>
<li><p><strong>缺点</strong>：</p>
<ol>
<li><p><strong>上下文切换</strong>。频繁的上下文切换会影响多线程的执行速度。</p>
</li>
<li><p><strong>死锁</strong>。多线程并发执行可能会产生死锁。</p>
</li>
<li><p><strong>受资源限制</strong>。程序执行的速度受限于计算机的硬件或软件资源。</p>
</li>
</ol>
</li>
</ul>
<h1 id="4、什么是线程的上下文切换？"><a href="#4、什么是线程的上下文切换？" class="headerlink" title="4、什么是线程的上下文切换？"></a>4、什么是线程的上下文切换？</h1><p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配 CPU 时间片来实现这个机制。</p>
<p>时间片是 CPU 分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。  </p>
<p>CPU 会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，<strong>从任务保存到再加载的过程就是一次上下文切换</strong>。  </p>
<h1 id="5、守护线程和用户线程区别"><a href="#5、守护线程和用户线程区别" class="headerlink" title="5、守护线程和用户线程区别"></a>5、守护线程和用户线程区别</h1><ul>
<li><strong>用户线程：</strong>平时用到的线程均为用户线程。</li>
<li><strong>守护线程：</strong>用来<strong>服务用户线程</strong>的线程，例如垃圾回收线程。</li>
</ul>
<p>任何线程都可以设置为守护线程和用户线程，通过方法 <code>Thread.setDaemon(boolean on)</code>设置，<code>true </code>则是将该线程设置为守护线程，<code>false </code>则是将该线程设置为用户线程。同时，<code>Thread.setDaemon()</code>必须在 <code>Thread.start()</code>之前调用，否则运行时会抛出异常。 </p>
<p>守护线程和用户线程的<strong>主要区别在于线程结束后 Java 虚拟机是否结束</strong>。</p>
<ul>
<li>用户线程：当任何一个用户线程未结束，Java 虚拟机是不会结束的。</li>
<li>守护线程：如果只剩守护线程未结束，Java 虚拟机是会结束的。</li>
</ul>
<h1 id="6、死锁、活锁、饥饿"><a href="#6、死锁、活锁、饥饿" class="headerlink" title="6、死锁、活锁、饥饿"></a>6、死锁、活锁、饥饿</h1><ul>
<li><p><strong>死锁</strong>：由于两个或两个以上的线程相互竞争对方的资源，而同时不释放自己的资源，导致所有线程<strong>同时</strong>被阻塞。</p>
</li>
<li><p><strong>活锁</strong>：任务执行时没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、失败。例如，线程 1 和线程 2 都需要获取一个资源，但他们同时让其他线程先获取该资源，<strong>两个线程一直谦让</strong>，最后都无法获取。  </p>
</li>
<li><p><strong>饥饿</strong>：以打印机打印文件为例，当有多个线程需要打印文件，如果系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。 </p>
<p>产生饥饿的原因：<strong>高优先级的线程占用了低优先级线程的CPU时间</strong>。</p>
</li>
</ul>
<h2 id="6-1-死锁的四个必要条件"><a href="#6-1-死锁的四个必要条件" class="headerlink" title="6.1 死锁的四个必要条件"></a>6.1 死锁的四个必要条件</h2><ol>
<li>互斥条件：一个资源在同一时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程在请求被占资源时<strong>发生阻塞</strong>，并对已获得的资源<strong>保持不放</strong>。</li>
<li>循环等待条件：发生死锁时，所有的线程会形成死循环，一直阻塞。</li>
<li>不可剥夺条件：线程已获得的资源在未使用完的情况下，不能被其他线程剥夺，只能由自己使用完释放资源。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">            <span class="comment">//返回当前正在执行的线程对象</span></span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;wait get resource2&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">            <span class="comment">//返回当前正在执行的线程对象</span></span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;wait get resource1&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679971332893-1221d08f-561e-4b6c-98df-7878b3c46c92.png" alt="运行结果"/></div><div class="image-meta"><span class="image-caption center">运行结果</span></div></div>
<p>线程1通过<code>synchronized(resource1)</code>获得resource1的监视器锁，然后通过<code>Thread.sleep(1000)</code>，让线程1休眠1s，为的是让线程2行动，然后获取到resource2的监视器锁。线程1和线程2休眠结束后，都开始企图获取对方的资源，然后这两个线程都会陷入互相等待的状态，于是产生了死锁。</p>
<h2 id="6-2-如何预防和避免死锁"><a href="#6-2-如何预防和避免死锁" class="headerlink" title="6.2 如何预防和避免死锁?"></a>6.2 如何预防和避免死锁?</h2><h3 id="6-2-1-如何预防死锁？"><a href="#6-2-1-如何预防死锁？" class="headerlink" title="6.2.1 如何预防死锁？"></a>6.2.1 如何预防死锁？</h3><p>破坏死锁产生的必要条件即可：</p>
<ol>
<li>破坏请求与保持条件：一次性申请所有资源。</li>
<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它所占有的资源。</li>
<li>破坏循环等待条件：按照顺序申请资源。比如按某一顺序申请资源，释放资源时则反序释放。</li>
</ol>
<h3 id="6-2-2-如何避免死锁？"><a href="#6-2-2-如何避免死锁？" class="headerlink" title="6.2.2 如何避免死锁？"></a>6.2.2 如何避免死锁？</h3><p>在资源分配时，借助算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。<br>将上面线程2的代码改成下面这样就不会产生死锁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1)&#123;</span><br><span class="line">        <span class="comment">//返回当前正在执行的线程对象</span></span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;wait get resource2&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679972267521-94b147b9-4101-4a3c-929e-0a7d583890af.png" alt="运行结果"/></div><div class="image-meta"><span class="image-caption center">运行结果</span></div></div>

<h2 id="6-3-死锁、活锁、饥饿的区别"><a href="#6-3-死锁、活锁、饥饿的区别" class="headerlink" title="6.3 死锁、活锁、饥饿的区别"></a>6.3 死锁、活锁、饥饿的区别</h2><ol>
<li>活锁是在不断尝试，而死锁是一直在等待；</li>
<li>活锁有可能自行解开，而死锁无法自行解开；</li>
<li>饥饿可以自行解开，而死锁不行；</li>
</ol>
<h1 id="7、线程的生命周期"><a href="#7、线程的生命周期" class="headerlink" title="7、线程的生命周期"></a>7、线程的生命周期</h1><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679985603801-0dd06916-a144-4e5e-bbde-d3b1620eb47f.png" alt="线程的生命周期"/></div><div class="image-meta"><span class="image-caption center">线程的生命周期</span></div></div>

<ol>
<li>线程创建后将处于<strong>NEW初始</strong>状态，调用<code>start()</code>方法后开始运行，此时线程处于<strong>READY就绪</strong>状态。</li>
<li>可运行状态的线程获取CPU时间片后就处于<strong>RUNNING运行中</strong>状态。</li>
<li>当线程执行<code>wait()</code>方法后，线程进入<strong>WATING等待</strong>状态，进入等待状态的线程需要依靠其他线程的通知才能返回到运行状态，而<strong>TIMED_WATING超时等待</strong>状态相当于在等待状态的基础上增加了超时限制，比如通过<code>sleep(long millis)</code>方法或者<code>wait(long millis)</code>方法可以将Java线程置于超时状态。</li>
<li>当超时时间到达后Java线程将会回到<strong>RUNNABLE状态</strong>。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程会进入<strong>BLOCKED阻塞状态，</strong>一直到获取到锁。</li>
<li>线程在执行<strong>RUNNABLE</strong>的<code>run()</code>方法后会进入到<strong>TERMINATED</strong>终止状态。</li>
</ol>
<h1 id="8、创建线程的方式？"><a href="#8、创建线程的方式？" class="headerlink" title="8、创建线程的方式？"></a>8、创建线程的方式？</h1><h2 id="8-1-继承Thread类创建线程"><a href="#8-1-继承Thread类创建线程" class="headerlink" title="8.1 继承Thread类创建线程"></a>8.1 继承Thread类创建线程</h2><p>首先继承Thread类，重写<code>run()</code>方法，在<code>main()</code>函数中调用子类实例的<code>start()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;run()方法正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        threadDemo.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;main()方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679986933617-7cfc130e-49f5-4e4c-a986-d0bf750507eb.png" alt="运行结果"/></div><div class="image-meta"><span class="image-caption center">运行结果</span></div></div>

<h2 id="8-2-实现Runnable接口创建线程"><a href="#8-2-实现Runnable接口创建线程" class="headerlink" title="8.2 实现Runnable接口创建线程"></a>8.2 实现Runnable接口创建线程</h2><p>首先创建实现Runnable接口的类RunnableDemo，重写<code>run()</code>方法；<br>创建类RunnableDemo的实例对象runnableDemo，以此为参数创建Thread对象，调用<code>start()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;run()方法正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;main()方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3-使用Callable和Future创建线程"><a href="#8-3-使用Callable和Future创建线程" class="headerlink" title="8.3 使用Callable和Future创建线程"></a>8.3 使用Callable和Future创建线程</h2><ol>
<li>创建Callable接口的实现类CallableDemo，重写<code>call()</code>方法。</li>
<li>以类CallableDemo的实例化对象作为参数创建FutureTask对象。</li>
<li>以FutureTask对象作为参数创建Thread对象。</li>
<li>调用Thread对象的<code>start()</code>方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;call()方法执行中&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; integerFutureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(integerFutureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;返回结果&quot;</span> + integerFutureTask.get());</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;main()方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-使用线程池"><a href="#8-4-使用线程池" class="headerlink" title="8.4 使用线程池"></a>8.4 使用线程池</h2><p>例如Executor框架，可以提供四种线程池：</p>
<ol>
<li><code>newCachedThreadPool</code>创建一个<strong>可缓存</strong>的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><code>newFixedThreadPool</code>创建一个<strong>定长</strong>的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li><code>newScheduledThreadPool</code>创建一个<strong>定长</strong>的线程池，<strong>支持定时及周期性</strong>任务执行。</li>
<li><code>newSingleThreadExecutor</code>创建一个<strong>单线程化</strong>的线程池，只会用<strong>唯一</strong>的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定长度的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现接口</span></span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将线程放入池中执行</span></span><br><span class="line">        fixedThreadPool.execute(t1);</span><br><span class="line">        fixedThreadPool.execute(t2);</span><br><span class="line">        fixedThreadPool.execute(t3);</span><br><span class="line">        fixedThreadPool.execute(t4);</span><br><span class="line">        fixedThreadPool.execute(t5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1679990092390-4558bb87-ad46-44ef-86c3-9d35747cf21b.png" alt="image.png"/></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div>

<h1 id="9、runnable和callable区别"><a href="#9、runnable和callable区别" class="headerlink" title="9、runnable和callable区别"></a>9、runnable和callable区别</h1><p><strong>相同点：</strong></p>
<ol>
<li>两者都是接口；</li>
<li>都需要调动<code>Thread.start()</code>启动线程。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>callable的核心是<code>call()</code>方法，<strong>允许返回值</strong>；而runnable的核心是<code>run()</code>方法，<strong>没有返回值</strong>。</li>
<li><code>call()</code>方法可以抛出异常，但是<code>run()</code>方法不行。</li>
<li>callable和runnable都可以应用于executors，但Thread类只支持runnable。</li>
</ol>
<h1 id="10、start-和run"><a href="#10、start-和run" class="headerlink" title="10、start()和run()"></a>10、start()和run()</h1><h2 id="10-1-两者区别"><a href="#10-1-两者区别" class="headerlink" title="10.1 两者区别"></a>10.1 两者区别</h2><ol>
<li>线程是通过Thread对象所对应的方法<code>run()</code>来完成其操作的，而线程的启动是通过<code>start()</code>方法执行。</li>
<li><code>run()</code>方法可以重复调用，<code>start()</code>方法只调用一次。</li>
</ol>
<h2 id="10-2-为什么调用start方法时会执行run方法，而不直接执行run方法？"><a href="#10-2-为什么调用start方法时会执行run方法，而不直接执行run方法？" class="headerlink" title="10.2 为什么调用start方法时会执行run方法，而不直接执行run方法？"></a>10.2 为什么调用start方法时会执行run方法，而不直接执行run方法？</h2><p>当 new 一个 Thread 时，线程进入了新建状态。</p>
<p>调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。<code>start()</code>会执行线程的相应准备工作，然后自动执行<code>run()</code>方法的内容，这是真正的多线程工作。 </p>
<p>但是，如果直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一 个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。 </p>
<p><strong>总结</strong>：调用 <code>start()</code>方法才可以<strong>启动线程</strong>并使线程进入<strong>就绪状态</strong>，直接执行<code>run()</code>方法的话<strong>不会</strong>以多线程的方式执行。  </p>
<h1 id="11、线程同步和调度的方法（对线程的控制方法）"><a href="#11、线程同步和调度的方法（对线程的控制方法）" class="headerlink" title="11、线程同步和调度的方法（对线程的控制方法）"></a>11、线程同步和调度的方法（对线程的控制方法）</h1><ul>
<li><code>wait()</code>：使一个线程处于等待（阻塞）状态，并且<strong>释放所持有的对象的锁</strong>。</li>
<li><code>sleep()</code>：使当前线程进入指定毫秒数的休眠，暂停执行，需要处理异常<code>InterruptedException</code>，<strong>不会释放持有的锁</strong>。</li>
<li><code>notify()</code>：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并<strong>不能精准</strong>的唤醒某一个等待的线程，而是JVM确定唤醒哪个线程，与优先级无关。</li>
<li><code>notifyAll()</code>：唤醒所有处于等待状态的线程，该方法<strong>并不是将对象的锁给所有线程</strong>，而是让它们竞争，<strong>只有获得锁的线程才能进入就绪状态</strong>。</li>
<li><code>join()</code>：与<code>sleep()</code>方法一样，是一个可中断的方法，在一个线程中调用另一个线程的<code>join()</code>方法，会使得当前的线程挂起，直到执行<code>join()</code>方法的线程结束。例如在B线程中调用A线程的<code>join()</code>方法，B线程进入了阻塞状态，直到A线程结束或者到达指定时间。</li>
<li><code>yield()</code>：提醒调度器当前线程愿意放弃当前的CPU资源，使得当前线程从运行状态切换到就绪状态。</li>
</ul>
<h1 id="12、sleep-和yield-区别"><a href="#12、sleep-和yield-区别" class="headerlink" title="12、sleep()和yield()区别"></a>12、sleep()和yield()区别</h1><ul>
<li><code>sleep()</code>方法会使得当前线程暂停指定的时间，没有消耗CPU时间片。</li>
<li><code>sleep()</code>使得线程进入阻塞状态，<code>yield()</code>方法只是对CPU进行提示，如果CPU没有忽略这个提示，会使得线程上下文的切换，进入到就绪状态。</li>
<li><code>sleep()</code>需要抛出异常，而<code>yield()</code>不需要抛出异常。</li>
<li><code>sleep()</code>会完成给定的休眠时间，<code>yield()</code>不一定。</li>
</ul>
<h1 id="13、sleep-和wait-的区别"><a href="#13、sleep-和wait-的区别" class="headerlink" title="13、sleep()和wait()的区别"></a>13、sleep()和wait()的区别</h1><p><strong>相同点：</strong></p>
<ol>
<li>都能使线程进入到等待状态。</li>
<li>都是可中断方法，被中断后都会收到中断异常。</li>
</ol>
<hr>
<p><strong>不同点：</strong></p>
<ol>
<li><code>wait()</code>是Object方法，<code>sleep()</code>是Thread方法。</li>
<li><code>wait()</code>必须在同步方法中进行，<code>sleep()</code>不需要。</li>
<li>线程同步方法中执行<code>sleep()</code>不会释放monitor的锁，而<code>wait()</code>方法会释放monitor的锁。</li>
<li><code>sleep()</code>方法在短暂的休眠后会主动退出阻塞，而<code>wait()</code>方法在没有指定时间的情况下，需要被其他线程中断才可以退出阻塞。</li>
</ol>
<h1 id="14、线程间通信方式"><a href="#14、线程间通信方式" class="headerlink" title="14、线程间通信方式"></a>14、线程间通信方式</h1><ol>
<li>共享变量：多个线程通过访问共享变量来实现通信。一般情况下需要使用 <strong>synchronized</strong> 或者 <strong>volatile</strong> 来保证共享变量的可见性和原子性。</li>
<li><code>wait/notify</code>：多个线程之间通过调用对象的 <strong>wait()</strong> 和 <strong>notify()</strong> 方法来实现通信。其中，<strong>wait()</strong> 方法会让当前线程进入等待状态，并且释放对象的锁；而 <strong>notify()</strong> 方法会唤醒等待队列中的某个线程，让其进入就绪状态。</li>
<li>Condition：<strong>Condition</strong> 接口提供了类似 <strong>wait&#x2F;notify</strong> 的功能，但是相比之下更加灵活。通过 <strong>Condition</strong> 接口的 <strong>await()</strong> 和 <strong>signal()</strong> 方法，可以实现多个线程之间的等待和唤醒操作。</li>
<li>管道：通过管道实现线程之间的通信。一般情况下，需要使用 <strong>PipedInputStream</strong> 和 <strong>PipedOutputStream</strong> 来实现管道流。</li>
<li>队列：线程间可以通过队列来传递数据。一个线程将数据放入队列的一端，另一个线程从队列的另一端取出数据。常用的队列实现包括BlockingQueue、ConcurrentLinkedQueue等。</li>
</ol>
<h1 id="15、如何实现线程同步和互斥？"><a href="#15、如何实现线程同步和互斥？" class="headerlink" title="15、如何实现线程同步和互斥？"></a>15、如何实现线程同步和互斥？</h1><p><strong>线程互斥：</strong>指某一个资源只能被一个访问者访问，具有唯一性和排他性。但访问者对资源访问的顺序是<strong>乱序</strong>的。<br><strong>线程同步：</strong>指在互斥的基础上使得访问者对资源进行<strong>有序访问</strong>。<br><strong>线程同步的实现方法：</strong></p>
<ul>
<li>同步方法</li>
<li>同步代码块</li>
<li><code>wait()</code>和<code>notify()</code></li>
<li>使用volatile实现线程同步</li>
<li>使用重入锁实现线程同步</li>
<li>使用局部变量实现线程同步</li>
<li>使用阻塞队列实现线程同步</li>
</ul>
<h1 id="16、线程安全"><a href="#16、线程安全" class="headerlink" title="16、线程安全"></a>16、线程安全</h1><h2 id="16-1-什么是线程安全？"><a href="#16-1-什么是线程安全？" class="headerlink" title="16.1 什么是线程安全？"></a>16.1 什么是线程安全？</h2><p>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</p>
<h2 id="16-2-如何保证线程安全？"><a href="#16-2-如何保证线程安全？" class="headerlink" title="16.2 如何保证线程安全？"></a>16.2 如何保证线程安全？</h2><ul>
<li>使用<strong>同步锁</strong>。用<code>synchronized</code>关键字或<code>ReentrantLock</code>类对共享资源加锁，保证同一时刻只有一个线程能够访问共享资源。</li>
<li>使用<code>volatile</code>关键字，保证共享变量的<strong>可见性</strong>和<strong>禁止指令重排</strong>。</li>
<li>使用线程安全的类。</li>
</ul>
<h2 id="16-3-线程安全体现在什么方面？"><a href="#16-3-线程安全体现在什么方面？" class="headerlink" title="16.3 线程安全体现在什么方面？"></a>16.3 线程安全体现在什么方面？</h2><ol>
<li>原子性：对共享变量互斥访问，同一个时刻只能有一个线程对数据操作；</li>
<li>可见性：当一个线程修改主内存后，其他变量能及时看到；</li>
<li>有序性：一个线程中的指令执行是有序的。</li>
</ol>
<h1 id="17、如何让三个线程T1、T2、T3按顺序执行这类问题？"><a href="#17、如何让三个线程T1、T2、T3按顺序执行这类问题？" class="headerlink" title="17、如何让三个线程T1、T2、T3按顺序执行这类问题？"></a>17、如何让三个线程T1、T2、T3按顺序执行这类问题？</h1><p>这是一道面试中常考的并发编程代码题，类似的题还有：</p>
<ul>
<li>三个线程T1、T2、T3轮流打印ABC，打印n次，如ABCABCABC……</li>
<li>两个线程交替打印1-100的奇偶数</li>
<li>N个线程循环打印1-100</li>
<li>……</li>
</ul>
<p>其实这类问题的本质都是<strong>线程通信</strong>问题，思路基本上都是<strong>一个线程执行完，阻塞该线程，唤醒其他线程</strong>，然后按顺序执行下一个线程。</p>
<h2 id="17-1-如何按顺序执行三个线程？"><a href="#17-1-如何按顺序执行三个线程？" class="headerlink" title="17.1 如何按顺序执行三个线程？"></a>17.1 如何按顺序执行三个线程？</h2><h3 id="17-1-1-synchronized-wait-notify"><a href="#17-1-1-synchronized-wait-notify" class="headerlink" title="17.1.1 synchronized + wait&#x2F;notify"></a>17.1.1 synchronized + wait&#x2F;notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(String name, <span class="type">int</span> targetNum)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">        <span class="comment">//让其他线程陷入阻塞状态</span></span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.print(name);</span><br><span class="line">        <span class="comment">//唤醒所有线程</span></span><br><span class="line">        LOCK.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;A&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;C&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-2-三个线程轮流打印n次ABC"><a href="#17-2-三个线程轮流打印n次ABC" class="headerlink" title="17.2 三个线程轮流打印n次ABC"></a>17.2 三个线程轮流打印n次ABC</h2><p>这个只需要在上面代码的基础上，加一个n次的循环即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(String name, <span class="type">int</span> targetNum)</span>&#123;</span><br><span class="line">    <span class="comment">//加个循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK)&#123;</span><br><span class="line">            <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1680060401101-d4bbca67-b73f-4326-a23a-01b91ac1998a.png" alt="image.png"/></div><div class="image-meta"><span class="image-caption center">image.png</span></div></div>
<p>基本思路：A B C三个线程同时启动，因为变量<code>num</code>的初始值为0，所以线程B、C拿到锁后，进入<code>while()</code>循环，然后执行<code>wait()</code>方法，线程阻塞，释放锁。只有A拿到锁后，不仅如此<code>while()</code>循环，执行<code>num++</code>，打印字符A，最后唤醒其他两个线程。这个时候变量<code>num</code>为1，所以线程B拿到锁后，不被阻塞，执行<code>num++</code>，打印字符B，最后唤醒其他两个线程。后面打印字符C也是相同的流程。</p>
<h3 id="17-2-1-join-方法"><a href="#17-2-1-join-方法" class="headerlink" title="17.2.1 join()方法"></a>17.2.1 join()方法</h3><p><code>join()</code>方法：在A线程中调用了B线程的<code>join()</code>方法时，表示只有当B线程执行完毕时，A线程才能继续执行。<br>基于这个原理，我们可以使得三个线程按照顺序执行，然后循环多次即可。无论三个线程谁先谁后，顺序最后都是A-B-C。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">printABC</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">printABC</span><span class="params">(Thread beforeThread)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.beforeThread = beforeThread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeThread != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeThread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printABC</span>(<span class="literal">null</span>), <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printABC</span>(t1), <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">printABC</span>(t2), <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>join</code>好处就是不论三个线程启动的顺序咋样，线程B只会在A线程执行完后，才会执行，C只会在B执行完后执行。</p>
<h3 id="17-2-2-Lock锁"><a href="#17-2-2-Lock锁" class="headerlink" title="17.2.2 Lock锁"></a>17.2.2 Lock锁</h3><p>其实原理一样，使用lock锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> num;    <span class="comment">//当前状态值：保证三个线程之间交替打印</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(String name, <span class="type">int</span> targetNum)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>;) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">3</span> == targetNum)&#123;</span><br><span class="line">            num++;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;A&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;C&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-3-Lock-Condition精准唤醒"><a href="#17-2-3-Lock-Condition精准唤醒" class="headerlink" title="17.2.3 Lock+Condition精准唤醒"></a>17.2.3 Lock+Condition精准唤醒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> num;    <span class="comment">//当前状态值：保证三个线程之间交替打印</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printABC</span><span class="params">(String name, <span class="type">int</span> targetNum, Condition currentThread, Condition nextThread)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>;) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num % <span class="number">3</span> != targetNum) &#123;</span><br><span class="line">                currentThread.await();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            nextThread.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;A&quot;</span>,<span class="number">0</span>, c1, c2);</span><br><span class="line">    &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>, c2, c3);</span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.printABC(<span class="string">&quot;C&quot;</span>,<span class="number">2</span>, c3, c1);</span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-3-两个线程交替打印1-100的奇偶数"><a href="#17-3-两个线程交替打印1-100的奇偶数" class="headerlink" title="17.3 两个线程交替打印1-100的奇偶数"></a>17.3 两个线程交替打印1-100的奇偶数</h2><p>基本思路：也是用synchronized+wait方法进行打印<br>当数字是奇数时，打印数字，然后唤醒另一个线程打印偶数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;                                <span class="comment">//全局计数器，从1开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">Lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();           <span class="comment">//用于线程同步的锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> targetNum)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Lock)&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((num % <span class="number">2</span>) == targetNum)&#123;    		<span class="comment">//如果是要求的数，就打印</span></span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                num++;</span><br><span class="line">                Lock.notifyAll();                   <span class="comment">//打印完然后唤醒另一个线程</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                  <span class="comment">//否则就释放锁，并等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">0</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">1</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-4-N个线程循环打印1-100"><a href="#17-4-N个线程循环打印1-100" class="headerlink" title="17.4 N个线程循环打印1-100"></a>17.4 N个线程循环打印1-100</h2><p>当N为4时，循环打印1-100，解决方法一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;                                <span class="comment">//全局计数器，从1开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">Lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();           <span class="comment">//用于线程同步的锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> targetNum)</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Lock)&#123;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((num % <span class="number">4</span>) == targetNum)&#123;    <span class="comment">//如果是要求的数，就打印</span></span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                num++;</span><br><span class="line">                Lock.notifyAll();                   <span class="comment">//打印完然后唤醒另一个线程</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                  <span class="comment">//否则就释放锁，并等待</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">0</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">1</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">2</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        main.print(<span class="number">3</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18、synchronized关键字"><a href="#18、synchronized关键字" class="headerlink" title="18、synchronized关键字"></a>18、synchronized关键字</h1><h2 id="18-1-什么是synchronized关键字"><a href="#18-1-什么是synchronized关键字" class="headerlink" title="18.1 什么是synchronized关键字"></a>18.1 什么是synchronized关键字</h2><p>多个线程同时访问共享资源时会出现一些问题，而<code>synchronized</code>关键字是用来<strong>保证线程同步</strong>的。</p>
<h2 id="18-2-Java内存的可见性问题"><a href="#18-2-Java内存的可见性问题" class="headerlink" title="18.2 Java内存的可见性问题"></a>18.2 Java内存的可见性问题</h2><p>在了解 <code>synchronized</code> 关键字的底层原理前，需要先简单了解下 Java 的内存模型，看看 <code>synchronized</code> 关键字是如何起作用的。 </p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/1680077763217-dbbeb71d-40bf-4268-8a6b-c6e5765b8293.png" alt="内存模型"/></div><div class="image-meta"><span class="image-caption center">内存模型</span></div></div>

<h3 id="18-2-1-什么是内存不可见问题？"><a href="#18-2-1-什么是内存不可见问题？" class="headerlink" title="18.2.1 什么是内存不可见问题？"></a>18.2.1 什么是内存不可见问题？</h3><p>Java中内存不可见问题是指当多个线程访问同一共享变量时，一个线程修改了这个变量的值，其他线程可能无法立即看到修改后的值，从而出现数据不一致的问题。</p>
<p>这是因为每个线程都有自己的工作内存，线程间共享变量时，为了提高性能，JVM会把变量缓存到每个线程的本地工作内存中，而不是直接读取主内存中的值。当一个线程修改了共享变量的值时，修改后的值可能还没有同步到主内存中，其他线程读取的仍是旧值，从而导致数据不一致。</p>
<h3 id="18-2-2-synchronized关键字是怎么解决的？"><a href="#18-2-2-synchronized关键字是怎么解决的？" class="headerlink" title="18.2.2 synchronized关键字是怎么解决的？"></a>18.2.2 synchronized关键字是怎么解决的？</h3><p>其实 <code>synchronized</code> 就是把在 <code>synchronized</code> 块内使用到的变量<strong>从线程的本地内存中擦除</strong>，这样在 <code>synchronized</code> 块中再次使用到该变量就不能从本地内存中获取了，需要从主内存中获取，<strong>确保变量的修改和读取都在主内存中进行</strong>，避免了了内存不可见问题。  </p>
<h2 id="18-3-synchronized关键字三大特性？"><a href="#18-3-synchronized关键字三大特性？" class="headerlink" title="18.3 synchronized关键字三大特性？"></a>18.3 synchronized关键字三大特性？</h2><ul>
<li><strong>原子性：</strong>一个或多个操作要么全部执行成功，要么全部执行失败。<code>synchronized</code>关键字可以保证只有一个线程拿到锁，访问共享资源。</li>
<li><strong>可见性：</strong>当一个线程对共享变量进行修改之后，其他线程就可以立刻看到。执行<code>synchronized</code>时，会对应执行<code>lock</code>、<code>unlock</code>原子操作，保证可见性。</li>
<li><strong>有序性：</strong>程序的执行顺序会按照代码的先后顺序执行。</li>
</ul>
<h2 id="18-4-synchronized关键字可以实现什么类型的锁？"><a href="#18-4-synchronized关键字可以实现什么类型的锁？" class="headerlink" title="18.4 synchronized关键字可以实现什么类型的锁？"></a>18.4 synchronized关键字可以实现什么类型的锁？</h2><ul>
<li><strong>悲观锁：</strong>每次访问共享资源时都会上锁。</li>
<li><strong>非公平锁：</strong>线程获取锁的顺序并不一定是按照线程阻塞的顺序。</li>
<li><strong>可重入锁：</strong>已经获取锁的线程可以再次获取锁。</li>
<li><strong>独占锁&#x2F;排他锁：</strong>该锁只能被一个线程所持有，其他线程均被阻塞。</li>
</ul>
<h3 id="18-4-1-可重入锁的原理知道吗？"><a href="#18-4-1-可重入锁的原理知道吗？" class="headerlink" title="18.4.1 可重入锁的原理知道吗？"></a>18.4.1 可重入锁的原理知道吗？</h3><p>简单来说，当线程请求一个由其它线程持有的对象锁时，该线程会阻塞；而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。</p>
<p>可重入锁实现的原理是：每一个锁关联一个<strong>线程id</strong>和<strong>重入次数计数器</strong>，</p>
<ul>
<li>当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；</li>
<li>当某一线程请求成功后，JVM会记下锁的持有线程id，并且将计数器置为 1；<ul>
<li>如果此时其它线程请求该锁，则必须等待；</li>
<li>如果该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时重入次数计数器会递增；</li>
<li>如果该线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</li>
</ul>
</li>
</ul>
<h2 id="18-5-使用方式"><a href="#18-5-使用方式" class="headerlink" title="18.5 使用方式"></a>18.5 使用方式</h2><ol>
<li>修饰普通同步方法：<strong>给当前对象实例加锁</strong>；</li>
<li>修饰静态同步方法：<strong>给当前类加锁</strong>；</li>
<li>修饰同步方法块：<strong>给指定对象或类加锁</strong>；</li>
</ol>
<h3 id="18-5-1-修饰普通同步方法"><a href="#18-5-1-修饰普通同步方法" class="headerlink" title="18.5.1 修饰普通同步方法"></a>18.5.1 修饰普通同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>给当前对象实例加锁</strong>，进入同步代码前要获得<strong>当前对象实例的锁</strong>。</p>
<h3 id="18-5-2-修饰静态同步方法"><a href="#18-5-2-修饰静态同步方法" class="headerlink" title="18.5.2 修饰静态同步方法"></a>18.5.2 修饰静态同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰静态同步方法也就是<strong>给当前类加锁</strong>，会作用于类的所有对象实例 ，进入同步代码前要获得<strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员(static 表明这是该类的一个静态资源，不管 new 了多少个对象， 只有一份)。<br>所以，如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法是允许的，不会发生互斥现象.<br>因为<strong>访问静态</strong> synchronized 方法<strong>占用的锁是当前类的锁</strong>，而<strong>访问非静态</strong> synchronized 方法<strong>占用的锁是当前实例对象锁</strong>。  </p>
<h3 id="18-5-3-修饰同步方法块"><a href="#18-5-3-修饰同步方法块" class="headerlink" title="18.5.3 修饰同步方法块"></a>18.5.3 修饰同步方法块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰同步方法块，表示<strong>对给定对象&#x2F;类加锁</strong>。<br><code>synchronized(this|object)</code> 表示进入同步代码库前<strong>要获得给定对象的锁</strong>。<br><code>synchronized(类.class)</code>表示进入同步代码前<strong>要获得当前 class 的锁</strong>。  </p>
<h2 id="18-6-底层原理"><a href="#18-6-底层原理" class="headerlink" title="18.6 底层原理"></a>18.6 底层原理</h2><p>synchronized关键字底层原理属于JVM层面的东西。</p>
<h3 id="18-6-1-修饰同步语块的情况"><a href="#18-6-1-修饰同步语块的情况" class="headerlink" title="18.6.1 修饰同步语块的情况"></a>18.6.1 修饰同步语块的情况</h3><p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230901104453943.png" alt="synchronized关键字原理"/></div><div class="image-meta"><span class="image-caption center">synchronized关键字原理</span></div></div>

<p>从上面可以看出<code>synchronized</code>同步语块的实现使用的是<code>monitorenter</code>和<code>monitorexit</code>指令，其中前者指向同步代码块的开始位置，后者指向代码块结束的位置。</p>
<p>当执行<code>monitorenter</code>指令时，线程试图获取锁，也就是获取**对象监视器<code>monitor</code>**的持有权。</p>
<hr>
<p>另外，<code>wait/notify</code>方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用这两个方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>异常的原因。</p>
<hr>
<p><code>synchronized</code>是可重入锁的实现原理：</p>
<p>当执行<code>monitorenter</code>指令时，线程试图获取锁，如果锁的计数器为0，则表示锁可以被获取，获取后将锁的计数器设为1。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331142513380.png" alt="执行monitorenter"/></div><div class="image-meta"><span class="image-caption center">执行monitorenter</span></div></div>

<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。整个流程与上面获取锁的流程相同。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331142651178.png" alt="执行monitorexit"/></div><div class="image-meta"><span class="image-caption center">执行monitorexit</span></div></div>

<h3 id="18-6-2-修饰方法的情况"><a href="#18-6-2-修饰方法的情况" class="headerlink" title="18.6.2 修饰方法的情况"></a>18.6.2 修饰方法的情况</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230901104759524.png" alt="synchronized关键字原理"/></div><div class="image-meta"><span class="image-caption center">synchronized关键字原理</span></div></div>

<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h3 id="18-6-3-总结"><a href="#18-6-3-总结" class="headerlink" title="18.6.3 总结"></a>18.6.3 总结</h3><ul>
<li><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
</li>
<li><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
</li>
</ul>
<p>不过两者的<strong>本质都是对对象监视器monitor的获取</strong>。</p>
<h3 id="18-6-4-能具体说一下Monitor吗？"><a href="#18-6-4-能具体说一下Monitor吗？" class="headerlink" title="18.6.4 能具体说一下Monitor吗？"></a>18.6.4 能具体说一下Monitor吗？</h3><p>对象监视器monitor存在于每个对象的对象头中，synchronized锁便是通过这种方式获取锁的。</p>
<p>其内部维护了三个变量：</p>
<ul>
<li>WaitSet：保存处于Waiting状态的线程；</li>
<li>EntryList：保存处于Blocked状态的线程；</li>
<li>Owner：持有锁的线程；</li>
</ul>
<p>一个线程获取到锁的标志就是在monitor中设置成功了Owner，一个monitor中只能有一个Owner。</p>
<p>在上锁的过程中，如果有其他线程来抢锁，则进入EntryList进行阻塞状态，当获得锁的线程执行完毕，释放了锁，就会唤醒EntryList中等待的线程竞争锁，竞争的过程是<strong>非公平</strong>的。</p>
<h2 id="18-7-JDK1-6对synchronized做了哪些优化？"><a href="#18-7-JDK1-6对synchronized做了哪些优化？" class="headerlink" title="18.7 JDK1.6对synchronized做了哪些优化？"></a>18.7 JDK1.6对synchronized做了哪些优化？</h2><p>在 jdk1.6 中，为了减少<strong>获得锁</strong>和<strong>释放锁</strong>带来的性能开销，引入了大量优化，如<strong>偏向锁</strong>、<strong>轻量级锁</strong>、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来<strong>减少锁操作的开销</strong>。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会<strong>随着竞争的激烈而逐渐升级</strong>。注意锁<strong>可以升级不可一级一级的降级</strong>，当锁释放之后会重新回归无锁状态，不会一级一级的往下降，而是直接变成无锁状态，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li>偏向锁（Biased Locking）：<ul>
<li>偏向锁是在<strong>无竞争</strong>的情况下对锁进行优化的机制。它的目标是<strong>减少无竞争情况下的锁操作的开销</strong>。</li>
<li>当一个线程获得了偏向锁后，之后再次进入同步块时<strong>无需重新获取锁，而是直接进入</strong>。</li>
<li>偏向锁的撤销机制是当其他线程试图竞争偏向锁时，持有偏向锁的线程会被挂起，<strong>偏向锁会升级为轻量级锁。</strong></li>
</ul>
</li>
<li>轻量级锁（Lightweight Locking）：<ul>
<li>轻量级锁是在有<strong>少量竞争</strong>的情况下对锁进行优化的机制。</li>
<li>当第一个线程进入同步块时，它会尝试使用 CAS（Compare and Swap）操作将对象头部的标记字段替换为指向锁记录的指针，这个过程是无锁的。</li>
<li>如果 CAS 操作成功，线程就获得了轻量级锁。如果 CAS 操作失败，表示有竞争，<strong>线程会膨胀为重量级锁</strong>。</li>
</ul>
</li>
<li>重量级锁（Heavyweight Locking）：<ul>
<li>重量级锁是在存在<strong>激烈竞争</strong>或<strong>轻量级锁膨胀失败</strong>的情况下使用的锁机制。</li>
<li>当一个线程尝试获取一个被重量级锁保护的同步块时，它会被阻塞，进入等待状态。</li>
<li>重量级锁使用操作系统的同步原语来实现，比如使用操作系统的互斥量或监视器锁。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">锁</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td align="center">加锁和解锁不需要额外的消耗，和执行非同步代码方法的性能相差无几。</td>
<td align="center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td align="center">适用只有一个线程访问的同步场景。</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td align="center">如果始终得不到锁竞争的线程，使用自旋会消耗CPU。</td>
<td align="center">追求响应时间，同步块执行速度非常快。</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">线程竞争不适用自旋，不会消耗CPU。</td>
<td align="center">线程阻塞，响应时间缓慢。</td>
<td align="center">追求吞吐量，同步块执行时间速度较长。</td>
</tr>
</tbody></table>
<h2 id="18-8-synchronized和lock两者的区别"><a href="#18-8-synchronized和lock两者的区别" class="headerlink" title="18.8 synchronized和lock两者的区别"></a>18.8 synchronized和lock两者的区别</h2><ol>
<li>语法层面<ul>
<li><code>synchronized</code>是关键字，源码在JVM中，是由C++实现的，退出同步代码块锁会自动释放；</li>
<li><code>Lock</code>是接口，源码由JDK提供，用JAVA语言实现，需要手动用<code>unlock</code>方法释放锁；</li>
</ul>
</li>
<li>功能层面<ul>
<li>二者都属于悲观锁，都具备基本的互斥、同步、锁重入的功能；</li>
<li><code>Lock</code>提供了更多的功能，比如等待状态、公平锁、可打断、可超时等等，同时<code>Lock</code>可以实现不同的场景，比如ReentrantLock等；</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有或竞争少时，<code>synchronized</code>做了许多优化，比如偏向锁、轻量级锁；</li>
<li>在竞争激烈时，<code>Lock</code>的性能会更好；</li>
</ul>
</li>
</ol>
<h2 id="18-9-了解ReentrantLock吗？"><a href="#18-9-了解ReentrantLock吗？" class="headerlink" title="18.9 了解ReentrantLock吗？"></a>18.9 了解ReentrantLock吗？</h2><p>ReentrantLock是java并发包下面的Lock接口的一个实现类，其丰富的功能与synchronized对比更加灵活，与synchronized一样都是悲观锁。</p>
<p>ReentrantLock是一个<strong>可重入锁</strong>，当调用lock方法获取锁之后，再次调用lock时，是不会再阻塞的，内部直接增加重入次数即可，代表这个线程已经重复获取一把锁而不需要等待锁的释放。</p>
<p>ReentrantLock的底层实现<strong>原理主要是利用CAS+AQS队列</strong>来实现的，默认是<strong>非公平锁</strong>。</p>
<h2 id="18-10-ReentrantLock和synchronized的区别是什么？"><a href="#18-10-ReentrantLock和synchronized的区别是什么？" class="headerlink" title="18.10 ReentrantLock和synchronized的区别是什么？"></a>18.10 ReentrantLock和synchronized的区别是什么？</h2><p><strong>相同点</strong>：</p>
<ol>
<li>两者都是<strong>可重入锁</strong>；</li>
<li>两者都是<strong>悲观锁</strong>；</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li>ReentrantLock是<strong>显式锁</strong>，需要手动调用<code>lock()</code>方法获取锁，再通过<code>unLock()</code>方法释放锁，而synchronized是<strong>隐式锁</strong>，通过关键字修饰的代码块或方法时自动获取和释放锁。</li>
<li>ReentrantLock可以设置公平锁和非公平锁，但是synchronized是非公平锁。</li>
<li>ReentrantLock可以在等待锁的过程中响应中断请求，synchronized在等待锁的过程中无法响应中断请求。</li>
<li>ReentrantLock可以绑定多个条件。</li>
</ol>
<h1 id="19、volatile关键字"><a href="#19、volatile关键字" class="headerlink" title="19、volatile关键字"></a>19、volatile关键字</h1><p><strong>作用：</strong>保证线程之间的变量可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p>注意：<code>volatile</code>关键字能保证数据的<strong>可见性</strong>、<strong>有序性</strong>，但是<strong>不能保证数据的原子性</strong>。而<code>synchronized</code>关键字两者都能保证。</p>
<h2 id="19-1-为什么代码会重排？"><a href="#19-1-为什么代码会重排？" class="headerlink" title="19.1 为什么代码会重排？"></a>19.1 为什么代码会重排？</h2><p>计算机在执行程序的过程中，编译器和处理器通常会对指令进行重排序，这样做的目的是为了提高性能。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331150713518.png" alt="代码重排"/></div><div class="image-meta"><span class="image-caption center">代码重排</span></div></div>

<p>左边这段代码，不断地交替读取a，b，会导致寄存器频繁交替存储a和b，使得代码的性能下降。</p>
<p>但是如果使用右边的这种重排序方式，避免交替读取a和b，这就是重排序的意义。</p>
<p>指令重排序一般分为<strong>编译器优化</strong>重排、<strong>指令并行</strong>重排、<strong>内存系统</strong>重排三种：</p>
<ul>
<li>编译器优化重排：编译器在不改变单线程程序语义的情况下，可以对语句的执行顺序进行重新排序。</li>
<li>指令并行重排：对于不存在<strong>数据依赖</strong>的程序，处理器可以对机器指令的执行顺序进行重新排列。</li>
<li>内存系统重排：因为处理器使用缓存和读&#x2F;写缓冲区，使得加载（load）和 存储（store）看上去像是在乱序执行。</li>
</ul>
<p>这三种指令重排说明了一个问题，那就是指令重排<strong>在单线程下可以提高代码的性能</strong>，但是在多线程下会出现问题。</p>
<h2 id="19-2-重排序会引发什么问题？"><a href="#19-2-重排序会引发什么问题？" class="headerlink" title="19.2 重排序会引发什么问题？"></a>19.2 重排序会引发什么问题？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;              <span class="comment">//操作1</span></span><br><span class="line">    flag = <span class="literal">true</span>;        <span class="comment">//操作2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;          <span class="comment">//操作3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a + a;  <span class="comment">//操作4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程1先执行<code>writer()</code>方法，随后线程2执行<code>reader()</code>方法，最后程序一定能得到正确的结果吗？</p>
<p>不一定。如果操作1和操作2进行了重排序，线程1先执行操作2，也就是<code>flag = true</code>；然后线程2执行操作3和操作4，在执行操作4时，不能正确读取到a的值，导致最终程序运行结果出问题，这说明在多线程代码中，重排序会破坏多线程的语义。</p>
<h2 id="19-3-volatile实现原理"><a href="#19-3-volatile实现原理" class="headerlink" title="19.3 volatile实现原理"></a>19.3 volatile实现原理</h2><h3 id="19-3-1-实现可见性原理"><a href="#19-3-1-实现可见性原理" class="headerlink" title="19.3.1 实现可见性原理"></a>19.3.1 实现可见性原理</h3><p><strong>导致内存不可见的主要原因：</strong>Java内存模型中本地内存和主内存之间的值不一致导致的。</p>
<p><code>volatile</code>可以保证内存可见性的关键是 <code>volatile</code>的读&#x2F;写实现了<strong>缓存一致性</strong>。</p>
<p>缓存一致性的主要内容为： 每个处理器会通过<strong>嗅探总线上的数据</strong>来查看自己的数据<strong>是否过期</strong>，一旦处理器发现自己缓存对应的内存地址被修改，就会将当前处理器的缓存设为无效状态。此时，如果处理器要获取这个数据，必须得重新从主内存将其读取到本地内存。 当处理器写数据时，如果发现操作的是共享变量，会通知其他处理器将该变量的缓存设为无效状态。</p>
<p> <strong>那缓存一致性是如何实现的呢？</strong></p>
<p>可以发现通过 volatile 修饰的变量，在生成汇编指令时会比普通的变量多出一个 <code>Lock</code>指令，这个 <code>Lock </code>指令就是 <code>volatile </code>关键字可以保证内存可见性的关键，它主要有两个作用：</p>
<p>（1）将当前处理器缓存的数据刷新到主内存。</p>
<p>（2）刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</p>
<h3 id="19-3-2-实现有序性原理"><a href="#19-3-2-实现有序性原理" class="headerlink" title="19.3.2 实现有序性原理"></a>19.3.2 实现有序性原理</h3><p>为了实现 <code>volatile </code>的内存语义，编译器在生成字节码时会通过<strong>插入内存屏障</strong>来禁止指令重排序。</p>
<p><strong>内存屏障</strong>：是一种 CPU 指令，<u>它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</u></p>
<p><strong>Java内存模型把内存屏障分为4类，分别是<code>LoadLoad</code>、<code>StoreStore</code>、<code>LoadStore</code>、<code>StoreLoad</code>。</strong></p>
<p>根据Java内存模型对编译器指定的重排序规则为：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230731144913812.png" alt="重排序规则"/></div><div class="image-meta"><span class="image-caption center">重排序规则</span></div></div>

<ul>
<li>volatile写操作上面加ss屏障：禁止上面的普通写和下面的volatile写重排序；</li>
<li>volatile写操作下面加sl屏障：禁止上面的volatile写和下面可能的volatile读&#x2F;写重排序；</li>
<li>volatile读操作下面加ll屏障：禁止上面的volatile读和下面所有的普通读重排序；</li>
<li>volatile读操作下面加ls屏障：禁止上面的volatile读和下面所有的普通写重排序；</li>
</ul>
<p>通过这四个重排序规则，volatile关键字可以禁止指令重排，实现有序性。</p>
<p>面试题：<strong>用双重校验锁的方式实现单例模式（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//用private修饰构造函数可以避免被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//先判断对象是否已经实例化过</span></span><br><span class="line">        <span class="comment">//没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uniqueInstance = new Singleton();</code>这段代码其实是分三步执行的：</p>
<ol>
<li>为<code>uniqueInstance</code>分配内存空间；</li>
<li>初始化<code>uniqueInstance</code>;</li>
<li>将<code>uniqueInstance</code>指向分配的内存空间。</li>
</ol>
<p>但是因为JVM具有指令重排的特性，执行的顺序可能会变成1-&gt;3-&gt;2。在单线程中指令重排不会出问题，但是在多线程的情况下，会导致一个线程获得还没有初始化的实例。比如，线程T1执行了1和3，此时T2调用<code>getUniqueInstance()</code>后发现<code>uniqueInstance</code>不为空，因此返回<code>uniqueInstance</code>，但是此时还进行第2步，也即还未初始化<code>uniqueInstance</code>。<br>使用<code>volatile</code>关键字可以禁止JVM指令重排，从而保证多线程环境下也能正常运行。</p>
<h1 id="20、synchronized和volatile的区别"><a href="#20、synchronized和volatile的区别" class="headerlink" title="20、synchronized和volatile的区别"></a>20、synchronized和volatile的区别</h1><ul>
<li><code>volatile </code>主要是保证<strong>内存的可见性</strong>，即变量在寄存器中的内存是不确定的， 需要从主存中读取。<code>synchronized </code>主要是解决多个线程<strong>访问资源的同步性</strong>。</li>
<li><code>volatile </code>作用于<strong>变量</strong>，<code>synchronized </code>作用于<strong>代码块</strong>或者<strong>方法</strong>。</li>
<li><code>volatile </code>不能保证数据的原子性。 <code>synchronized </code>可以保证数据的可见性和原子性。</li>
<li><code>volatile </code>不会造成线程的阻塞，<code>synchronized </code>会造成线程的阻塞。</li>
</ul>
<h1 id="21、乐观锁和悲观锁"><a href="#21、乐观锁和悲观锁" class="headerlink" title="21、乐观锁和悲观锁"></a>21、乐观锁和悲观锁</h1><p><strong>乐观锁</strong>：乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，<strong>只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了</strong>（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p><strong>悲观锁</strong>：悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h2 id="21-1-如何实现乐观锁？"><a href="#21-1-如何实现乐观锁？" class="headerlink" title="21.1 如何实现乐观锁？"></a>21.1 如何实现乐观锁？</h2><p><strong>版本号机制</strong>：一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>CAS算法</strong>：CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个<strong>预期值</strong>和<strong>要更新的变量值</strong>进行比较，两值相等才会进行更新。</p>
<p>CAS 是一个原子操作（即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成），底层依赖于一条 CPU 的原子指令。</p>
<p>CAS涉及到的三个操作数：</p>
<ul>
<li><strong>V</strong> ：要更新的变量值(Var)</li>
<li><strong>E</strong> ：预期值(Expected)</li>
<li><strong>N</strong> ：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了V，则当前线程放弃更新。</p>
<h2 id="21-2-乐观锁存在的问题"><a href="#21-2-乐观锁存在的问题" class="headerlink" title="21.2 乐观锁存在的问题"></a>21.2 乐观锁存在的问题</h2><p><strong>ABA问题</strong>：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，</p>
<p><strong>循环时间长开销大</strong>：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<h1 id="22、ThreadLocal"><a href="#22、ThreadLocal" class="headerlink" title="22、ThreadLocal"></a>22、ThreadLocal</h1><h2 id="22-1-什么是ThreadLocal？有哪些应用场景？"><a href="#22-1-什么是ThreadLocal？有哪些应用场景？" class="headerlink" title="22.1 什么是ThreadLocal？有哪些应用场景？"></a>22.1 什么是ThreadLocal？有哪些应用场景？</h2><p>ThreadLocal 为变量在每个线程中都创建了一个副本，每个线程可以访问自己内部的副本变量， 并且不会和其他线程的局部变量冲突，<strong>实现了线程间的数据隔离，同时实现了线程内的资源共享</strong>。</p>
<p><strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<p>应用场景：</p>
<ul>
<li>使用 ThreadLocal 进行跨函数数据传递（比如传递请求过程中的用户ID、Session、传递HTTP用的请求实例HttpRequest）</li>
<li>使用 ThreadLocal 实现线程间数据隔离 </li>
<li>使用 ThreadLocal 实现数据库连接</li>
</ul>
<h2 id="22-2-ThreadLocal原理"><a href="#22-2-ThreadLocal原理" class="headerlink" title="22.2 ThreadLocal原理"></a>22.2 ThreadLocal原理</h2><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230331170315399.png" alt="image-20230331170315399"/></div><div class="image-meta"><span class="image-caption center">image-20230331170315399</span></div></div>

<p>每一个 Thread 线程内部都有一个 Map（ThreadLocalMap），如果给一个 Thread 创建多个 ThreadLocal 实例，然后放置本地数据，那么当前线程的 ThreadLocalMap 中就会有多个“Key-Value 对”，其中 ThreadLocal 实例为 Key，本地数据为 Value。</p>
<p>每一个线程在获取本地值时，都会将 ThreadLocal 实例作为 Key 从自己拥有的 ThreadLocalMap 中获取值，别的线程无法访问自己的 ThreadLocalMap 实例，自己也无法访问别人的 ThreadLocalMap 实例， 达到相互隔离，互不干扰。</p>
<p>ThreadLocal 的操作都是基于 ThreadLocalMap 展开的，而 ThreadLocalMap 是 ThreadLocal 的一个静态内部类，其实现了一套简单的 Map 结构（比 HashMap 简单）。其中<code>get()</code> 、 <code>set()</code> 、 <code>remove()</code> 方法都涉及 ThreadLocalMap 的方法调用。</p>
<h2 id="22-3-什么导致了ThreadLocal内存泄露问题？"><a href="#22-3-什么导致了ThreadLocal内存泄露问题？" class="headerlink" title="22.3 什么导致了ThreadLocal内存泄露问题？"></a>22.3 什么导致了ThreadLocal内存泄露问题？</h2><p><code>ThreadLocalMap</code> 中使用的 <strong>key 为 <code>ThreadLocal</code> 的弱引用</strong>，而 <strong>value 是强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p>
<p>解决方法：<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。<strong>使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法清理。</strong></p>
<hr>
<p><strong>弱引用：</strong>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<h1 id="23、线程池"><a href="#23、线程池" class="headerlink" title="23、线程池"></a>23、线程池</h1><h2 id="23-1-什么是线程池？为什么使用线程池？"><a href="#23-1-什么是线程池？为什么使用线程池？" class="headerlink" title="23.1 什么是线程池？为什么使用线程池？"></a>23.1 什么是线程池？为什么使用线程池？</h2><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<p>使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="23-2-如何创建线程池？"><a href="#23-2-如何创建线程池？" class="headerlink" title="23.2 如何创建线程池？"></a>23.2 如何创建线程池？</h2><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>
<ol>
<li><code>newCachedThreadPool</code>创建一个<strong>可缓存</strong>的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程；</li>
<li><code>newFixedThreadPool</code>创建一个<strong>定长</strong>的线程池，可控制线程最大并发数，超出的线程会在队列中等待；</li>
<li><code>newScheduledThreadPool</code>创建一个可以执行<strong>延迟任务</strong>的线程池，支持定时和周期性任务；</li>
<li><code>newSingleThreadExecutor</code>创建一个<strong>单线程化</strong>的线程池，只会用<strong>唯一</strong>的工作线程来执行任务，保证所有任务按照指定顺序执行。</li>
</ol>
<h3 id="23-2-1-为什么不推荐使用Executors方式创建线程池？"><a href="#23-2-1-为什么不推荐使用Executors方式创建线程池？" class="headerlink" title="23.2.1  为什么不推荐使用Executors方式创建线程池？"></a>23.2.1  为什么不推荐使用Executors方式创建线程池？</h3><ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h3 id="23-2-2-线程池核心参数有哪些？如何解释？"><a href="#23-2-2-线程池核心参数有哪些？如何解释？" class="headerlink" title="23.2.2 线程池核心参数有哪些？如何解释？"></a>23.2.2 线程池核心参数有哪些？如何解释？</h3><p><strong><code>ThreadPoolExecutor</code> 7 个核心的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> 核心线程数目:</strong> 线程池中会保留的最多线程数；</li>
<li>**<code>maximumPoolSize</code>最大线程数目 :**核心线程+救急线程的最大数目。</li>
<li><strong><code>workQueue</code>阻塞队列:</strong> 当没有空闲的核心线程时，新任务会进入次队列排队等待，队列满的话就会创建救急线程执行任务；</li>
<li><strong><code>keepAliveTime</code>生存时间：</strong>救急线程的存活时间，如果生存时间内没有新任务，线程资源就会被释放；</li>
<li><strong><code>unit</code>时间单位：</strong>救急线程生存时间的单位。</li>
<li><strong><code>threadFactory</code>线程工厂：</strong>定制线程对象的创建。</li>
<li><strong><code>handler</code>拒绝策略：</strong> 当所有线程都在繁忙、阻塞队列也放满时，会触发拒绝策略。</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410153830053.png" alt="image-20230410153830053" style="zoom:50%;" />

<h3 id="23-2-3-线程池的拒绝策略有哪些？"><a href="#23-2-3-线程池的拒绝策略有哪些？" class="headerlink" title="23.2.3 线程池的拒绝策略有哪些？"></a>23.2.3 线程池的拒绝策略有哪些？</h3><ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 直接抛出异常来拒绝新任务的处理，<strong>默认策略</strong>。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 用调用者所在的线程来执行任务；</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 丢弃阻塞队列中最靠前的任务，并执行当前任务。</li>
</ul>
<h3 id="23-2-4-线程池常见的阻塞队列有哪些？"><a href="#23-2-4-线程池常见的阻塞队列有哪些？" class="headerlink" title="23.2.4 线程池常见的阻塞队列有哪些？"></a>23.2.4 线程池常见的阻塞队列有哪些？</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li><code>ArrayBlockingQueue</code>（有界队列）：基于<strong>数组</strong>结构的<strong>有界</strong>阻塞队列，FIFO，强制有界，只有一把锁；</li>
<li><code>LinkedBlockingQueue</code>（无界队列）：基于<strong>链表</strong>结构的<strong>无界</strong>阻塞队列，FIFO，可以有界，头尾都有锁。</li>
<li><code>SynchronousQueue</code>（同步队列） ：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：是一个优先级队列，可以保证每次出队的任务都是当前队列中执行时间最靠前的；</li>
</ul>
<h3 id="23-2-5-线程池处理任务的流程（线程池执行原理是什么？）"><a href="#23-2-5-线程池处理任务的流程（线程池执行原理是什么？）" class="headerlink" title="23.2.5 线程池处理任务的流程（线程池执行原理是什么？）"></a>23.2.5 线程池处理任务的流程（线程池执行原理是什么？）</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410154615916.png" alt="image-20230410154615916"/></div><div class="image-meta"><span class="image-caption center">image-20230410154615916</span></div></div>

<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么会按照当前的拒绝策略来执行。</li>
</ol>
<h3 id="23-3-6-如何给线程命名？"><a href="#23-3-6-如何给线程命名？" class="headerlink" title="23.3.6 如何给线程命名？"></a>23.3.6 如何给线程命名？</h3><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>
<p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样的，没有业务含义，不利于我们定位问题。</p>
<p>给线程池里的线程命名通常有下面两种方式：</p>
<p>1、利用 guava 的 <code>ThreadFactoryBuilder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure>

<p>2、自己实现<code>ThreadFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-3-7-如何合理配置线程池大小？"><a href="#23-3-7-如何合理配置线程池大小？" class="headerlink" title="23.3.7 如何合理配置线程池大小？"></a>23.3.7 如何合理配置线程池大小？</h3><ul>
<li>如果业务是 <strong>CPU 密集型任务（N+1）</strong>：这种任务消耗的主要是 CPU 资源，可以将线程数设置为 <strong>N（CPU 核心数）+1</strong>。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li>如果业务是 <strong>IO 密集型任务（2N）</strong>：这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 <strong>2N</strong>。</li>
</ul>
<h3 id="23-3-8-如何判断任务时CPU密集型还是IO密集型？"><a href="#23-3-8-如何判断任务时CPU密集型还是IO密集型？" class="headerlink" title="23.3.8 如何判断任务时CPU密集型还是IO密集型？"></a>23.3.8 如何判断任务时CPU密集型还是IO密集型？</h3><p>CPU 密集型简单理解就是<strong>利用 CPU 计算能力的任务</strong>，比如<strong>在内存中对大量数据进行排序</strong>。</p>
<p>但凡涉及到<strong>网络读取，文件读取这类都是 IO 密集型</strong>，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="23-3-9-线程池回收线程的方法有哪些？"><a href="#23-3-9-线程池回收线程的方法有哪些？" class="headerlink" title="23.3.9 线程池回收线程的方法有哪些？"></a>23.3.9 线程池回收线程的方法有哪些？</h3><ol>
<li>对于核心线程来说：可以设置参数<code>allowCoreThreadTimeOut</code>为<code>true</code>，等待<code>keepAliveTime</code>时间后，线程就会被回收。</li>
<li>对于救急线程来说：等到<code>keepAliveTime</code>后，线程自动会被回收，也可以执行<code>executor.shutdown()</code>方法，立马回收救急线程。</li>
</ol>
<h3 id="23-3-10-如何判断线程池已经执行完所有任务？"><a href="#23-3-10-如何判断线程池已经执行完所有任务？" class="headerlink" title="23.3.10 如何判断线程池已经执行完所有任务？"></a>23.3.10 如何判断线程池已经执行完所有任务？</h3><ol>
<li>用<code>isTerminated()</code>方法判断线程池的状态，循环判断该方法的返回值，了解线程池的运行状态；使用该方法的前提是线程池需要调用shutdown方法，不然就会一直运行；</li>
<li>通过判断线程池中的计划执行任务数和已完成任务数来判断任务是否执行完，当两者相等时，说明线程池的人物全部都执行完毕了；</li>
<li>给<code>CountDownLatch</code>赋一个值为N的计数器，N为其中的任务数，每执行完一个任务，就让计数器-1，当计数器为0时，就说明任务都执行完毕。</li>
</ol>
<h2 id="23-3-线程池原理分析"><a href="#23-3-线程池原理分析" class="headerlink" title="23.3 线程池原理分析"></a>23.3 线程池原理分析</h2><p>首先创建一个 <code>Runnable</code> 接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试程序，使用<code>ThreadPoolExecutor</code>构造函数自定义参数的方式来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建workerThread对象</span></span><br><span class="line">            <span class="type">MyRunnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的代码中，指定了：</p>
<ul>
<li><p><code>corePoolSize</code>: 核心线程数为 5。</p>
</li>
<li><p><code>maximumPoolSize</code> ：最大线程数 10</p>
</li>
<li><p><code>keepAliveTime</code> : 等待时间为 1L。</p>
</li>
<li><p><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</p>
</li>
<li><p><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</p>
</li>
<li><p><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</p>
</li>
</ul>
<p>输出结果：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1Start. Time = Mon Apr 10 16:04:32 CST 2023</span><br><span class="line">pool-1-thread-2Start. Time = Mon Apr 10 16:04:32 CST 2023</span><br><span class="line">pool-1-thread-4Start. Time = Mon Apr 10 16:04:32 CST 2023</span><br><span class="line">pool-1-thread-5Start. Time = Mon Apr 10 16:04:32 CST 2023</span><br><span class="line">pool-1-thread-3Start. Time = Mon Apr 10 16:04:32 CST 2023</span><br><span class="line">pool-1-thread-5End. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-2End. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-1End. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-2Start. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-1Start. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-4End. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-4Start. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-5Start. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-3End. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-3Start. Time = Mon Apr 10 16:04:37 CST 2023</span><br><span class="line">pool-1-thread-5End. Time = Mon Apr 10 16:04:42 CST 2023</span><br><span class="line">pool-1-thread-1End. Time = Mon Apr 10 16:04:42 CST 2023</span><br><span class="line">pool-1-thread-2End. Time = Mon Apr 10 16:04:42 CST 2023</span><br><span class="line">pool-1-thread-3End. Time = Mon Apr 10 16:04:42 CST 2023</span><br><span class="line">pool-1-thread-4End. Time = Mon Apr 10 16:04:42 CST 2023</span><br><span class="line">Finished all thread</span><br></pre></td></tr></table></figure>

<p>线程池首先会执行5个任务，然后这些任务中，如果有被执行完的任务，就会被拿去新的任务执行。</p>
<p>首先分析一下 <code>execute</code>方法。 在示例代码中，我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去。</p>
<p>这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果当前工作线程数量为0，新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">// 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>execute</code> 方法中，多次调用 <code>addWorker</code> 方法。<code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</p>
<h2 id="23-4-几个常见的对比"><a href="#23-4-几个常见的对比" class="headerlink" title="23.4 几个常见的对比"></a>23.4 几个常见的对比</h2><h3 id="23-4-1-Runnable和Callable"><a href="#23-4-1-Runnable和Callable" class="headerlink" title="23.4.1 Runnable和Callable"></a>23.4.1 Runnable和Callable</h3><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,<strong>目的就是为了来处理<code>Runnable</code>不支持的用例</strong>。</p>
<p><strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<h3 id="23-4-2-excute-和submit"><a href="#23-4-2-excute-和submit" class="headerlink" title="23.4.2 excute()和submit()"></a>23.4.2 excute()和submit()</h3><p><code>execute()</code>方法用于提交<strong>不需要返回值的任务</strong>，所以无法判断任务是否被线程池执行成功与否；</p>
<p><code>submit()</code>方法用于提交<strong>需要返回值的任务</strong>。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法的话，如果在 <code>timeout</code> 时间内任务还没有执行完，就会抛出 <code>java.util.concurrent.TimeoutException</code>。</p>
<h3 id="23-4-3-shutdown-和shutdownNow"><a href="#23-4-3-shutdown-和shutdownNow" class="headerlink" title="23.4.3 shutdown()和shutdownNow()"></a>23.4.3 shutdown()和shutdownNow()</h3><p><code>shutdown()</code> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是<strong>队列里的任务得执行完毕</strong>。</p>
<p><code>shutdownNow()</code> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并<strong>停止处理排队的任务</strong>并返回正在等待执行的 List</p>
<h3 id="23-4-4-isTerminated-和isShutdown"><a href="#23-4-4-isTerminated-和isShutdown" class="headerlink" title="23.4.4 isTerminated()和isShutdown()"></a>23.4.4 isTerminated()和isShutdown()</h3><ul>
<li><code>isTerminated</code> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
<li><code>isShutDown</code> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
</ul>
<h1 id="24、CAS"><a href="#24、CAS" class="headerlink" title="24、CAS"></a>24、CAS</h1><p>CAS(Compare And Swap)是CPU指令级的原子操作，并且处于用户态下，所以其开销较小，性能更高。</p>
<p>是一种乐观锁技术，属于非阻塞算法。</p>
<h2 id="24-1-CAS的自旋过程？"><a href="#24-1-CAS的自旋过程？" class="headerlink" title="24.1 CAS的自旋过程？"></a>24.1 CAS的自旋过程？</h2><p>CAS 是一种无锁算法，该算法关键依赖三个值——<strong>当前值</strong>、<strong>期望值</strong>和<strong>更新值</strong>，底层 CPU 利用原子操作判断<strong>当前值</strong>与<strong>期望值</strong>是否相等，如果相等就给内存地址赋更新值，否则不做任何操作。使用 CAS 进行无锁编程的步骤大致如下：</p>
<ol>
<li>获得字段的<strong>当前值</strong>和<strong>期望值</strong>；</li>
<li>计算<strong>更新值</strong>；</li>
<li>通过CAS将<strong>更新值</strong>替换成<strong>当前值</strong>上，如果CAS失败，就重复第1步，一直到CAS成功，这就是CAS自旋。</li>
</ol>
<h2 id="24-2-CAS存在什么问题？如何解决？"><a href="#24-2-CAS存在什么问题？如何解决？" class="headerlink" title="24.2 CAS存在什么问题？如何解决？"></a>24.2 CAS存在什么问题？如何解决？</h2><ul>
<li>ABA问题，在乐观锁中有介绍。可以通过版本号来判断变量的值是否发生了变化，在CAS操作时同时比较版本号是否一致。</li>
<li>高并发下，自旋时间过长导致时间开销太大，性能很低。可以通过限制自旋次数来解决。</li>
<li>只能保证一个共享变量的原子操作。可以结合ReentrantLock和synchronized关键字来保证多个变量的原子性。</li>
</ul>
<h1 id="25、Atomic原子类"><a href="#25、Atomic原子类" class="headerlink" title="25、Atomic原子类"></a>25、Atomic原子类</h1><p>Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所谓原子类说简单点就是具有原子&#x2F;原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下</p>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<h2 id="25-1-基本类型"><a href="#25-1-基本类型" class="headerlink" title="25.1 基本类型"></a>25.1 基本类型</h2><ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code> ：布尔型原子类</li>
</ul>
<p>主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h2 id="25-2-数组类型"><a href="#25-2-数组类型" class="headerlink" title="25.2 数组类型"></a>25.2 数组类型</h2><ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code> ：引用类型数组原子类</li>
</ul>
<h2 id="25-3-引用类型"><a href="#25-3-引用类型" class="headerlink" title="25.3 引用类型"></a>25.3 引用类型</h2><ul>
<li><p><code>AtomicReference</code>：引用类型原子类</p>
</li>
<li><p><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，<strong>可用于解决原子的更新数据和数据的版本号</strong>，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p>
</li>
<li><p><code>AtomicMarkableReference</code> ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</p>
</li>
</ul>
<h2 id="25-4-对象的属性修改类型"><a href="#25-4-对象的属性修改类型" class="headerlink" title="25.4 对象的属性修改类型"></a>25.4 对象的属性修改类型</h2><ul>
<li><p><code>AtomicIntegerFieldUpdater</code>:原子更新整形字段的更新器</p>
</li>
<li><p><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</p>
</li>
<li><p><code>AtomicReferenceFieldUpdater</code> ：原子更新引用类型里的字段的更新器</p>
</li>
</ul>
<p>要想原子地更新对象的属性需要两步。</p>
<p>第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p>
<p>第二步，更新的对象属性必须使用 public volatile 修饰符。</p>
<h1 id="26、AQS"><a href="#26、AQS" class="headerlink" title="26、AQS"></a>26、AQS</h1><h2 id="26-1-什么是AQS？"><a href="#26-1-什么是AQS？" class="headerlink" title="26.1 什么是AQS？"></a>26.1 什么是AQS？</h2><p>AQS 的全称是 AbstractQueuedSynchronizer，是一个用来<strong>构建锁和同步器的框架</strong>，像 ReentrantLock，Semaphore，FutureTask 都是基于 AQS 实现的。</p>
<h2 id="26-2-AQS的原理"><a href="#26-2-AQS的原理" class="headerlink" title="26.2 AQS的原理"></a>26.2 AQS的原理</h2><p>简单来说，<strong>AQS 就是维护了一个共享资源，然后使用队列来保证线程排队获取资源的一个过程</strong>。</p>
<p>AQS 的原理图如下</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cccccpg-blog.oss-cn-chengdu.aliyuncs.com/image-20230410171701107.png" alt="image-20230410171701107"/></div><div class="image-meta"><span class="image-caption center">image-20230410171701107</span></div></div>

<p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</p>
<p>CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</p>
<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-3-AQS资源共享方式"><a href="#26-3-AQS资源共享方式" class="headerlink" title="26.3 AQS资源共享方式"></a>26.3 AQS资源共享方式</h2><ul>
<li><code>Exclusive</code>：独占，只有一个线程可以执行，如ReentrantLock</li>
<li><code>Share</code>：共享，可以多个线程同时执行，如Semaphore，CountDownLatch</li>
</ul>
<h2 id="26-4-AQS是如何实现独占锁和共享锁的？"><a href="#26-4-AQS是如何实现独占锁和共享锁的？" class="headerlink" title="26.4 AQS是如何实现独占锁和共享锁的？"></a>26.4 AQS是如何实现独占锁和共享锁的？</h2><ul>
<li><p>以<strong>独占式的 ReentrantLock 为例</strong>：</p>
<ul>
<li>AQS使用双向队列（CLH队列）来保存等待获取锁的线程。当一个线程尝试获取锁时，如果锁已被其他线程占用，该线程会被加入到等待队列中，等待获取锁。</li>
<li>在独占锁模式下，AQS会按照FIFO顺序唤醒等待队列中的线程，先到先得。</li>
<li>当持有锁的线程释放锁时，AQS会唤醒等待队列中的第一个线程，使其有机会获取锁。</li>
</ul>
</li>
<li><p>以<strong>共享式的 CountDownLatch 以例</strong>：</p>
<ul>
<li>在共享锁模式下，多个线程可以同时持有同一个锁，实现资源的共享访问。</li>
<li>AQS使用计数器来记录锁的持有情况。当一个线程尝试获取锁时，如果失败，则会进入队列等待，如果获取成功，则会让计数器+1，并通知队列中下一个线程，以实现共享的功能。</li>
<li>持有共享锁的线程在释放锁时，会递减计数器。当计数器归零时，表示没有线程持有该锁，其他线程可以尝试获取锁。</li>
</ul>
</li>
</ul>
<p> AQS 也支持自定义同步器<strong>同时实现独占和共享</strong>两种方式，如 ReentrantReadWriteLock</p>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/06/23/4-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">4.Java虚拟机</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/06/16/2-Java%E9%9B%86%E5%90%88/">2.Java集合</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">Cccccpg</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
